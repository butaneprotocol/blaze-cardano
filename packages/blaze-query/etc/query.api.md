## API Report File for "@blaze-cardano/query"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Address } from '@blaze-cardano/core';
import { AssetId } from '@blaze-cardano/core';
import type { Credential } from '@blaze-cardano/core';
import { DatumHash } from '@blaze-cardano/core';
import { Hash28ByteBase16 } from '@blaze-cardano/core';
import { NetworkId } from '@blaze-cardano/core';
import { PlutusData } from '@blaze-cardano/core';
import { PlutusLanguageVersion } from '@blaze-cardano/core';
import { ProtocolParameters } from '@blaze-cardano/core';
import { Redeemers } from '@blaze-cardano/core';
import type * as Schema from '@cardano-ogmios/schema';
import { Script } from '@blaze-cardano/core';
import { Slot } from '@blaze-cardano/core';
import { SlotConfig } from '@blaze-cardano/core';
import { Transaction } from '@blaze-cardano/core';
import { TransactionId } from '@blaze-cardano/core';
import { TransactionInput } from '@blaze-cardano/core';
import { TransactionUnspentOutput } from '@blaze-cardano/core';
import type { Unwrapped } from '@blaze-cardano/ogmios';

// @public (undocumented)
export class Blockfrost extends Provider {
    constructor(params: {
        network: NetworkName;
        projectId: string;
        withScriptRefCaching?: boolean;
    });
    awaitTransactionConfirmation(txId: TransactionId, timeout?: number): Promise<boolean>;
    evaluateTransaction(tx: Transaction, additionalUtxos?: TransactionUnspentOutput[]): Promise<Redeemers>;
    getParameters(): Promise<ProtocolParameters>;
    getUnspentOutputByNFT(nft: AssetId): Promise<TransactionUnspentOutput>;
    // Warning: (ae-forgotten-export) The symbol "BlockfrostUTxO" needs to be exported by the entry point index.d.ts
    getUnspentOutputs(address: Address | Credential, filter?: (utxo: BlockfrostUTxO) => boolean): Promise<TransactionUnspentOutput[]>;
    getUnspentOutputsWithAsset(address: Address | Credential, unit: AssetId): Promise<TransactionUnspentOutput[]>;
    // (undocumented)
    headers(): {
        project_id: string;
    };
    postTransactionToChain(tx: Transaction): Promise<TransactionId>;
    resolveDatum(datumHash: DatumHash): Promise<PlutusData>;
    // (undocumented)
    resolveScriptRef(script: Script | Hash28ByteBase16, address?: Address): Promise<TransactionUnspentOutput | undefined>;
    resolveUnspentOutputs(txIns: TransactionInput[]): Promise<TransactionUnspentOutput[]>;
    // (undocumented)
    url: string;
    // (undocumented)
    withScriptRefCaching: boolean;
}

// @public (undocumented)
export interface BlockfrostProtocolParametersResponse {
    // (undocumented)
    a0: string;
    // (undocumented)
    coins_per_utxo_size: number;
    // (undocumented)
    collateral_percent: number;
    // Warning: (ae-forgotten-export) The symbol "BlockfrostLanguageVersions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    cost_models: Record<BlockfrostLanguageVersions, {
        [key: string]: number;
    }>;
    // (undocumented)
    cost_models_raw: Record<BlockfrostLanguageVersions, number[]>;
    // (undocumented)
    decentralisation_param: number;
    // (undocumented)
    e_max: number;
    // (undocumented)
    epoch: number;
    // (undocumented)
    extra_entropy: null;
    // (undocumented)
    key_deposit: number;
    // (undocumented)
    max_block_ex_mem: number;
    // (undocumented)
    max_block_ex_steps: number;
    // (undocumented)
    max_block_header_size: number;
    // (undocumented)
    max_block_size: number;
    // (undocumented)
    max_collateral_inputs: number;
    // (undocumented)
    max_tx_ex_mem: number;
    // (undocumented)
    max_tx_ex_steps: number;
    // (undocumented)
    max_tx_size: number;
    // (undocumented)
    max_val_size: number;
    // (undocumented)
    min_fee_a: number;
    // (undocumented)
    min_fee_b: number;
    // (undocumented)
    min_fee_ref_script_cost_per_byte?: number;
    // (undocumented)
    min_pool_cost: number;
    // (undocumented)
    min_utxo: string;
    // (undocumented)
    n_opt: number;
    // (undocumented)
    nonce: string;
    // (undocumented)
    pool_deposit: number;
    // (undocumented)
    price_mem: string;
    // (undocumented)
    price_step: string;
    // (undocumented)
    protocol_major_ver: number;
    // (undocumented)
    protocol_minor_ver: number;
    // (undocumented)
    rho: string;
    // (undocumented)
    tau: string;
}

// @public (undocumented)
export const fromBlockfrostLanguageVersion: (x: BlockfrostLanguageVersions) => PlutusLanguageVersion;

// @public (undocumented)
export class Kupmios extends Provider {
    constructor(kupoUrl: string, ogmios: Unwrapped.Ogmios);
    awaitTransactionConfirmation(txId: TransactionId, timeout?: number): Promise<boolean>;
    // (undocumented)
    static readonly confirmationTimeout: number;
    evaluateTransaction(tx: Transaction, additionalUtxos: TransactionUnspentOutput[]): Promise<Redeemers>;
    getParameters(): Promise<ProtocolParameters>;
    getUnspentOutputByNFT(unit: AssetId): Promise<TransactionUnspentOutput>;
    getUnspentOutputs(address: Address): Promise<TransactionUnspentOutput[]>;
    getUnspentOutputsWithAsset(address: Address | null, unit: AssetId): Promise<TransactionUnspentOutput[]>;
    // (undocumented)
    kupoUrl: string;
    // (undocumented)
    ogmios: Unwrapped.Ogmios;
    // (undocumented)
    static readonly plutusVersions: string[];
    postTransactionToChain(tx: Transaction): Promise<TransactionId>;
    resolveDatum(datumHash: DatumHash): Promise<PlutusData>;
    resolveUnspentOutputs(txIns: TransactionInput[]): Promise<TransactionUnspentOutput[]>;
    static serializeUtxos(unspentOutputs: TransactionUnspentOutput[]): Schema.Utxo;
}

// @public (undocumented)
export type NetworkName = "cardano-mainnet" | "cardano-preprod" | "cardano-preview" | "cardano-sanchonet" | "unknown";

// @public
export abstract class Provider {
    constructor(network: NetworkId, networkName: NetworkName);
    abstract awaitTransactionConfirmation(txId: TransactionId, timeout?: number): Promise<boolean>;
    abstract evaluateTransaction(tx: Transaction, additionalUtxos: TransactionUnspentOutput[]): Promise<Redeemers>;
    abstract getParameters(): Promise<ProtocolParameters>;
    getSlotConfig(): SlotConfig;
    abstract getUnspentOutputByNFT(unit: AssetId): Promise<TransactionUnspentOutput>;
    abstract getUnspentOutputs(address: Address): Promise<TransactionUnspentOutput[]>;
    abstract getUnspentOutputsWithAsset(address: Address, unit: AssetId): Promise<TransactionUnspentOutput[]>;
    // (undocumented)
    network: NetworkId;
    // (undocumented)
    networkName: NetworkName;
    abstract postTransactionToChain(tx: Transaction): Promise<TransactionId>;
    abstract resolveDatum(datumHash: DatumHash): Promise<PlutusData>;
    resolveScriptRef(script: Script | Hash28ByteBase16, address?: Address): Promise<TransactionUnspentOutput | undefined>;
    abstract resolveUnspentOutputs(txIns: TransactionInput[]): Promise<TransactionUnspentOutput[]>;
    slotToUnix(slot: Slot | number | bigint): number;
    unixToSlot(unix_millis: bigint | number): Slot;
}

// @public
export const purposeToTag: {
    [key: string]: number;
};

// (No @packageDocumentation comment for this package)

```
