## API Report File for "@blaze-cardano/sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as bip39 from '@scure/bip39';
import * as C from '@cardano-sdk/core';
import { Cardano } from '@cardano-sdk/core';
import * as _cardano_sdk_util0 from '@cardano-sdk/util';
import * as Crypto from '@cardano-sdk/crypto';
import { Exact } from '@blaze-cardano/data';
import { HexBlob } from '@cardano-sdk/util';
import { OpaqueString } from '@cardano-sdk/util';
import * as Schema from '@cardano-ogmios/schema';
import { TArray } from '@blaze-cardano/data';
import { typedHex } from '@cardano-sdk/util';
import { Unwrapped } from '@blaze-cardano/ogmios';
import { wordlist } from '@scure/bip39/wordlists/english';

// @public (undocumented)
const Address: typeof C.Cardano.Address;

// @public (undocumented)
type Address = C.Cardano.Address;

// @public
const addressFromBech32: typeof C.Cardano.Address.fromBech32;

// @public
const addressFromCredential: (network: NetworkId, credential: Credential) => Address;

// @public
const addressFromCredentials: (network: NetworkId, paymentCredential: Credential, delegationCredential?: Credential) => Address;

// @public
const addressFromValidator: (network: NetworkId, validator: Script) => Address;

// @public (undocumented)
const AddressType: typeof C.Cardano.AddressType;

// @public (undocumented)
type AddressType = C.Cardano.AddressType;

// @public
export function applyParams(hex: HexBlob, ...params: PlutusData[]): HexBlob;

// @public
export function applyParamsToScript<T extends TArray>(plutusScript: string, type: T, params: Exact<T>): HexBlob;

// @public
export const assertLockAddress: (address: Address) => never | void;

// @public
export const assertPaymentsAddress: (address: Address) => never | void;

// @public
export const assertValidOutput: (output: TransactionOutput, coinsPerUtxoByte: number, maxValueSize: number) => void | never;

// @public (undocumented)
const AssetId: {
    (value: string): C.Cardano.AssetId;
    getPolicyId(id: C.Cardano.AssetId): C.Cardano.PolicyId;
    getAssetName(id: C.Cardano.AssetId): C.Cardano.AssetName;
    fromParts(policyId: C.Cardano.PolicyId, assetName: C.Cardano.AssetName): C.Cardano.AssetId;
};

// @public (undocumented)
type AssetId = C.Cardano.AssetId;

// @public (undocumented)
const AssetName: {
    (value: string): C.Cardano.AssetName;
    toUTF8(assetName: C.Cardano.AssetName, stripInvisibleCharacters?: boolean): string;
};

// @public (undocumented)
type AssetName = C.Cardano.AssetName;

// @public (undocumented)
const AuxiliaryData: typeof C.Serialization.AuxiliaryData;

// @public (undocumented)
type AuxiliaryData = C.Serialization.AuxiliaryData;

// @public
export const bigintMax: (a: bigint, b: bigint) => bigint;

// @public (undocumented)
const Bip32PrivateKey: typeof Crypto.Bip32PrivateKey;

// @public (undocumented)
type Bip32PrivateKey = Crypto.Bip32PrivateKey;

// @public (undocumented)
type Bip32PrivateKeyHex = OpaqueString<"Bip32PrivateKeyHex">;

// @public (undocumented)
const Bip32PrivateKeyHex: (value: string) => Bip32PrivateKeyHex;

// @public (undocumented)
const Bip32PublicKey: typeof Crypto.Bip32PublicKey;

// @public (undocumented)
type Bip32PublicKey = Crypto.Bip32PublicKey;

// @public
function blake2b_224(data: HexBlob): Hash28ByteBase16;

// @public
function blake2b_256(data: HexBlob): Hash32ByteBase16;

// @public
export class Blaze<ProviderType extends Provider, WalletType extends Wallet> {
    // (undocumented)
    static from<ProviderType extends Provider, WalletType extends Wallet>(provider: ProviderType, wallet: WalletType): Promise<Blaze<ProviderType, WalletType>>;
    newTransaction(): TxBuilder;
    // (undocumented)
    readonly params: ProtocolParameters;
    // (undocumented)
    readonly provider: ProviderType;
    signTransaction(tx: Transaction): Promise<Transaction>;
    submitTransaction(tx: Transaction, useProvider?: boolean): Promise<TransactionId>;
    // (undocumented)
    wallet: WalletType;
}

// @public (undocumented)
export class Blockfrost extends Provider {
    constructor(params: {
        network: NetworkName;
        projectId: string;
        withScriptRefCaching?: boolean;
    });
    awaitTransactionConfirmation(txId: TransactionId, timeout?: number): Promise<boolean>;
    evaluateTransaction(tx: Transaction, additionalUtxos?: TransactionUnspentOutput[]): Promise<Redeemers>;
    getParameters(): Promise<ProtocolParameters>;
    getUnspentOutputByNFT(nft: AssetId): Promise<TransactionUnspentOutput>;
    // Warning: (ae-forgotten-export) The symbol "BlockfrostUTxO" needs to be exported by the entry point index.d.ts
    getUnspentOutputs(address: Address | Credential, filter?: (utxo: BlockfrostUTxO) => boolean): Promise<TransactionUnspentOutput[]>;
    getUnspentOutputsWithAsset(address: Address | Credential, unit: AssetId): Promise<TransactionUnspentOutput[]>;
    // (undocumented)
    headers(): {
        project_id: string;
    };
    postTransactionToChain(tx: Transaction): Promise<TransactionId>;
    resolveDatum(datumHash: DatumHash): Promise<PlutusData>;
    // (undocumented)
    resolveScriptRef(script: Script | Hash28ByteBase16, address?: Address): Promise<TransactionUnspentOutput | undefined>;
    resolveUnspentOutputs(txIns: TransactionInput[]): Promise<TransactionUnspentOutput[]>;
    // (undocumented)
    url: string;
    // (undocumented)
    withScriptRefCaching: boolean;
}

// @public (undocumented)
export interface BlockfrostProtocolParametersResponse {
    // (undocumented)
    a0: string;
    // (undocumented)
    coins_per_utxo_size: number;
    // (undocumented)
    collateral_percent: number;
    // Warning: (ae-forgotten-export) The symbol "BlockfrostLanguageVersions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    cost_models: Record<BlockfrostLanguageVersions, {
        [key: string]: number;
    }>;
    // (undocumented)
    cost_models_raw: Record<BlockfrostLanguageVersions, number[]>;
    // (undocumented)
    decentralisation_param: number;
    // (undocumented)
    e_max: number;
    // (undocumented)
    epoch: number;
    // (undocumented)
    extra_entropy: null;
    // (undocumented)
    key_deposit: number;
    // (undocumented)
    max_block_ex_mem: number;
    // (undocumented)
    max_block_ex_steps: number;
    // (undocumented)
    max_block_header_size: number;
    // (undocumented)
    max_block_size: number;
    // (undocumented)
    max_collateral_inputs: number;
    // (undocumented)
    max_tx_ex_mem: number;
    // (undocumented)
    max_tx_ex_steps: number;
    // (undocumented)
    max_tx_size: number;
    // (undocumented)
    max_val_size: number;
    // (undocumented)
    min_fee_a: number;
    // (undocumented)
    min_fee_b: number;
    // (undocumented)
    min_fee_ref_script_cost_per_byte?: number;
    // (undocumented)
    min_pool_cost: number;
    // (undocumented)
    min_utxo: string;
    // (undocumented)
    n_opt: number;
    // (undocumented)
    nonce: string;
    // (undocumented)
    pool_deposit: number;
    // (undocumented)
    price_mem: string;
    // (undocumented)
    price_step: string;
    // (undocumented)
    protocol_major_ver: number;
    // (undocumented)
    protocol_minor_ver: number;
    // (undocumented)
    rho: string;
    // (undocumented)
    tau: string;
}

// @public
export function calculateMinAda(output: TransactionOutput, coinsPerUtxoByte: number): bigint;

// @public
export function calculateReferenceScriptFee(refScripts: Script[], params: ProtocolParameters): number;

// @public
export function calculateRequiredCollateral(fee: bigint, collateralPercentage: number): bigint;

// @public (undocumented)
const CborReader: typeof C.Serialization.CborReader;

// @public (undocumented)
type CborReader = C.Serialization.CborReader;

// @public (undocumented)
const CborReaderState: typeof C.Serialization.CborReaderState;

// @public (undocumented)
type CborReaderState = C.Serialization.CborReaderState;

// @public
const CborSet: typeof C.Serialization.CborSet;

// Warning: (ae-forgotten-export) The symbol "CborSerializable" needs to be exported by the entry point index.d.ts
//
// @public
type CborSet<A, B extends CborSerializable<A>> = C.Serialization.CborSet<A, B>;

// @public
export function cborToScript(cbor: string, type: ScriptType): Script;

// @public (undocumented)
const CborWriter: typeof C.Serialization.CborWriter;

// @public (undocumented)
type CborWriter = C.Serialization.CborWriter;

// @public (undocumented)
const Certificate: typeof C.Serialization.Certificate;

// @public (undocumented)
type Certificate = C.Serialization.Certificate;

// @public (undocumented)
const CertificateType: typeof C.Cardano.CertificateType;

// @public (undocumented)
type CertificateType = C.Cardano.CertificateType;

// @public (undocumented)
export interface CIP30DataSignature {
    // Warning: (ae-forgotten-export) The symbol "CoseKeyCborHex" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    key: CoseKeyCborHex;
    // Warning: (ae-forgotten-export) The symbol "CoseSign1CborHex" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    signature: CoseSign1CborHex;
}

// @public
export interface CIP30Interface {
    getBalance(): Promise<string>;
    getChangeAddress(): Promise<string>;
    getCollateral(): Promise<string[]>;
    getNetworkId(): Promise<number>;
    getRewardAddresses(): Promise<string[]>;
    getUnusedAddresses(): Promise<string[]>;
    getUsedAddresses(): Promise<string[]>;
    getUtxos(): Promise<string[] | undefined>;
    signData(address: string, payload: string): Promise<{
        signature: string;
        key: string;
    }>;
    signTx(tx: string, partialSign: boolean): Promise<string>;
    submitTx(tx: string): Promise<string>;
}

// @public (undocumented)
export namespace CoinSelector {
        { hvfSelector, micahsSelector };
}

// @public
export class ColdWallet implements Wallet {
    constructor(address: Address, networkId: NetworkId, provider: Provider);
    // (undocumented)
    readonly address: Address;
    getBalance(): Promise<Value_2>;
    getChangeAddress(): Promise<Address>;
    getCollateral(): Promise<TransactionUnspentOutput[]>;
    getNetworkId(): Promise<NetworkId>;
    getRewardAddresses(): Promise<RewardAddress[]>;
    getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    getUnusedAddresses(): Promise<Address[]>;
    getUsedAddresses(): Promise<Address[]>;
    // (undocumented)
    readonly networkId: NetworkId;
    postTransaction(tx: Transaction): Promise<TransactionId>;
    signData(_address: Address, _payload: string): Promise<CIP30DataSignature>;
    signTransaction(_tx: Transaction, _partialSign?: boolean): Promise<TransactionWitnessSet>;
}

// Warning: (ae-forgotten-export) The symbol "IScriptData" needs to be exported by the entry point index.d.ts
//
// @public
export function computeScriptData(redeemers: Redeemers, datums: ReturnType<TransactionWitnessSet["plutusData"]>,
// TODO: weird import shenanigans
usedCostModels: Costmdls): IScriptData | undefined;

// @public (undocumented)
const ConstrPlutusData: typeof C.Serialization.ConstrPlutusData;

// @public (undocumented)
type ConstrPlutusData = C.Serialization.ConstrPlutusData;

declare namespace Core {
    export {
        Address,
        AddressType,
        AssetId,
        AssetName,
        AuxiliaryData,
        Bip32PrivateKey,
        Bip32PrivateKeyHex,
        Bip32PublicKey,
        CborReader,
        CborReaderState,
        CborSet,
        CborWriter,
        Certificate,
        CertificateType,
        ConstrPlutusData,
        CostModel,
        CostModels,
        Costmdls,
        Credential,
        CredentialCore,
        CredentialType,
        Datum,
        DatumHash,
        DatumKind,
        Ed25519KeyHashHex,
        Ed25519PrivateExtendedKeyHex,
        Ed25519PrivateKey,
        Ed25519PrivateNormalKeyHex,
        Ed25519PublicKey,
        Ed25519PublicKeyHex,
        Ed25519Signature,
        Ed25519SignatureHex,
        Evaluator,
        ExUnits,
        Hash,
        Hash28ByteBase16,
        Hash32ByteBase16,
        HashAsPubKeyHex,
        HexBlob,
        Metadata,
        Metadatum,
        MetadatumList,
        MetadatumMap,
        MinFeeReferenceScripts,
        NativeScript,
        nativescript_d_exports as NativeScripts,
        NetworkId,
        OpaqueString,
        PaymentAddress,
        PlutusData,
        PlutusDataKind,
        PlutusLanguageVersion,
        PlutusList,
        PlutusMap,
        PlutusV1Script,
        PlutusV2Script,
        PlutusV3Script,
        PolicyId,
        PolicyIdToHash,
        PoolId,
        Prettier,
        ProtocolParameters,
        Redeemer,
        RedeemerPurpose,
        RedeemerTag,
        Redeemers,
        RewardAccount,
        RewardAddress,
        SLOT_CONFIG_NETWORK,
        Script,
        ScriptAll,
        ScriptAny,
        ScriptHash,
        ScriptNOfK,
        ScriptPubkey,
        SelectionPhase,
        Slot,
        SlotConfig,
        StakeDelegation,
        StakeDelegationCertificate,
        StakeDeregistration,
        StakeRegistration,
        TimelockExpiry,
        TimelockStart,
        TokenMap,
        Transaction,
        TransactionBody,
        TransactionId,
        TransactionInput,
        TransactionInputSet,
        TransactionMetadatumKind,
        TransactionOutput,
        TransactionUnspentOutput,
        TransactionWitnessPlutusData,
        TransactionWitnessSet,
        TxCBOR,
        UTxOSelectionError,
        Value_2 as Value,
        VkeyWitness,
        addressFromBech32,
        addressFromCredential,
        addressFromCredentials,
        addressFromValidator,
        blake2b_224,
        blake2b_256,
        derivePublicKey,
        entropyToMnemonic,
        fromHex,
        generateMnemonic,
        getBurnAddress,
        getPaymentAddress,
        hardCodedProtocolParams,
        mnemonicToEntropy,
        prettify,
        setInConwayEra,
        sha2_256,
        sha3_256,
        signMessage,
        toHex,
        typedHex,
        wordlist
    }
}

// @public (undocumented)
const Costmdls: typeof C.Serialization.Costmdls;

// @public (undocumented)
type Costmdls = C.Serialization.Costmdls;

// @public (undocumented)
const CostModel: typeof C.Serialization.CostModel;

// @public (undocumented)
type CostModel = C.Serialization.CostModel;

// @public (undocumented)
type CostModels = C.Cardano.CostModels;

// @public (undocumented)
const Credential: typeof C.Serialization.Credential;

// @public (undocumented)
type Credential = C.Serialization.Credential;

// @public (undocumented)
type CredentialCore = C.Cardano.Credential;

// @public (undocumented)
const CredentialType: typeof C.Cardano.CredentialType;

// @public (undocumented)
type CredentialType = C.Cardano.CredentialType;

// @public (undocumented)
const Datum: typeof C.Serialization.Datum;

// @public (undocumented)
type Datum = PlutusData | DatumHash;

// @public (undocumented)
const DatumHash: {
    (value: string): Crypto.Hash32ByteBase16;
    fromHexBlob<T>(value: _cardano_sdk_util0.HexBlob): T;
};

// @public (undocumented)
type DatumHash = Crypto.Hash32ByteBase16;

// @public (undocumented)
const DatumKind: typeof C.Serialization.DatumKind;

// @public
function derivePublicKey(privateKey: Ed25519PrivateNormalKeyHex | Ed25519PrivateExtendedKeyHex): Ed25519PublicKeyHex;

// @public (undocumented)
const Ed25519KeyHashHex: (value: string) => Crypto.Ed25519KeyHashHex;

// @public (undocumented)
type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;

// @public (undocumented)
type Ed25519PrivateExtendedKeyHex = OpaqueString<"Ed25519PrivateKeyHex">;

// @public (undocumented)
const Ed25519PrivateExtendedKeyHex: (value: string) => Ed25519PrivateExtendedKeyHex;

// @public (undocumented)
const Ed25519PrivateKey: typeof Crypto.Ed25519PrivateKey;

// @public (undocumented)
type Ed25519PrivateKey = Crypto.Ed25519PrivateKey;

// @public (undocumented)
type Ed25519PrivateNormalKeyHex = OpaqueString<"Ed25519PrivateKeyHex">;

// @public (undocumented)
const Ed25519PrivateNormalKeyHex: (value: string) => Ed25519PrivateNormalKeyHex;

// @public (undocumented)
const Ed25519PublicKey: typeof Crypto.Ed25519PublicKey;

// @public (undocumented)
type Ed25519PublicKey = Crypto.Ed25519PublicKey;

// @public (undocumented)
const Ed25519PublicKeyHex: (value: string) => Crypto.Ed25519PublicKeyHex;

// @public (undocumented)
type Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;

// @public (undocumented)
const Ed25519Signature: typeof Crypto.Ed25519Signature;

// @public (undocumented)
type Ed25519Signature = Crypto.Ed25519Signature;

// @public (undocumented)
const Ed25519SignatureHex: (value: string) => Crypto.Ed25519SignatureHex;

// @public (undocumented)
type Ed25519SignatureHex = Crypto.Ed25519SignatureHex;

// @public
const entropyToMnemonic: typeof bip39.entropyToMnemonic;

// @public (undocumented)
type Evaluator = (tx: Transaction, additionalUtxos: TransactionUnspentOutput[]) => Promise<Redeemers>;

// @public (undocumented)
type ExUnits = C.Serialization.ExUnits;

// @public (undocumented)
const ExUnits: typeof C.Serialization.ExUnits;

// @public (undocumented)
export const fromBlockfrostLanguageVersion: (x: BlockfrostLanguageVersions) => PlutusLanguageVersion;

// @public
function fromHex(hexString: string): Uint8Array;

// @public
const generateMnemonic: typeof bip39.generateMnemonic;

// @public
export const getAuxiliaryDataHash: (data: AuxiliaryData) => Hash32ByteBase16;

// @public (undocumented)
const getBurnAddress: (network: NetworkId) => C.Cardano.Address;

// @public
function getPaymentAddress(address: Address): PaymentAddress;

// @public (undocumented)
export function getScriptSize(script: Script): number;

// @public
const hardCodedProtocolParams: ProtocolParameters;

// @public (undocumented)
const Hash: typeof C.Serialization.Hash;

// @public (undocumented)
type Hash<T extends string> = C.Serialization.Hash<T>;

// @public (undocumented)
const Hash28ByteBase16: {
    (value: string): Crypto.Hash28ByteBase16;
    fromEd25519KeyHashHex(value: Crypto.Ed25519KeyHashHex): Crypto.Hash28ByteBase16;
};

// @public (undocumented)
type Hash28ByteBase16 = Crypto.Hash28ByteBase16;

// @public (undocumented)
const Hash32ByteBase16: {
    (value: string): Crypto.Hash32ByteBase16;
    fromHexBlob<T>(value: _cardano_sdk_util0.HexBlob): T;
};

// @public (undocumented)
type Hash32ByteBase16 = Crypto.Hash32ByteBase16;

// @public
function HashAsPubKeyHex(hash: Hash28ByteBase16): Ed25519PublicKeyHex;

// @public
export class HotSingleWallet implements Wallet {
    constructor(paymentSigningKey: Ed25519PrivateNormalKeyHex, networkId: NetworkId, provider: Provider, stakeSigningKey?: Ed25519PrivateNormalKeyHex);
    // (undocumented)
    readonly address: Address;
    getBalance(): Promise<Value_2>;
    getChangeAddress(): Promise<Address>;
    getCollateral(): Promise<TransactionUnspentOutput[]>;
    getNetworkId(): Promise<NetworkId>;
    getRewardAddresses(): Promise<RewardAddress[]>;
    getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    getUnusedAddresses(): Promise<Address[]>;
    getUsedAddresses(): Promise<Address[]>;
    // (undocumented)
    readonly networkId: NetworkId;
    postTransaction(tx: Transaction): Promise<TransactionId>;
    signData(address: Address, payload: string): Promise<CIP30DataSignature>;
    signTransaction(tx: Transaction, partialSign?: boolean): Promise<TransactionWitnessSet>;
}

// @public
export class HotWallet implements Wallet {
    // (undocumented)
    readonly address: Address;
    // (undocumented)
    static fromMasterkey(masterkey: Bip32PrivateKeyHex, provider: Provider, networkId?: NetworkId, addressType?: AddressType): Promise<HotWallet>;
    // (undocumented)
    static generateAccountAddressFromMasterkey(masterkey: Bip32PrivateKey, networkId?: NetworkId, addressType?: AddressType): Promise<{
        address: Address;
        paymentKey: Bip32PrivateKey;
        stakePaymentKey: Bip32PrivateKey;
        publicKey: Bip32PublicKey;
    }>;
    getBalance(): Promise<Value_2>;
    getChangeAddress(): Promise<Address>;
    getCollateral(): Promise<TransactionUnspentOutput[]>;
    getNetworkId(): Promise<NetworkId>;
    getRewardAddresses(): Promise<RewardAddress[]>;
    getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    getUnusedAddresses(): Promise<Address[]>;
    getUsedAddresses(): Promise<Address[]>;
    // (undocumented)
    readonly networkId: NetworkId;
    postTransaction(tx: Transaction): Promise<TransactionId>;
    // (undocumented)
    readonly rewardAddress: RewardAddress | undefined;
    signData(address: Address, payload: string): Promise<CIP30DataSignature>;
    signTransaction(tx: Transaction, partialSign?: boolean, signWithStakeKey?: boolean): Promise<TransactionWitnessSet>;
}

// @public
export const insertSorted: (arr: string[], el: string) => number;

// @public
export const isEqualInput: (self: TransactionInput, that: TransactionInput) => boolean;

// @public
export const isEqualOutput: (self: TransactionOutput, that: TransactionOutput) => boolean;

// @public
export const isEqualUTxO: (self: TransactionUnspentOutput, that: TransactionUnspentOutput) => boolean;

// @public (undocumented)
export class Kupmios extends Provider {
    constructor(kupoUrl: string, ogmios: Unwrapped.Ogmios);
    awaitTransactionConfirmation(txId: TransactionId, timeout?: number): Promise<boolean>;
    // (undocumented)
    static readonly confirmationTimeout: number;
    evaluateTransaction(tx: Transaction, additionalUtxos: TransactionUnspentOutput[]): Promise<Redeemers>;
    getParameters(): Promise<ProtocolParameters>;
    getUnspentOutputByNFT(unit: AssetId): Promise<TransactionUnspentOutput>;
    getUnspentOutputs(address: Address): Promise<TransactionUnspentOutput[]>;
    getUnspentOutputsWithAsset(address: Address | null, unit: AssetId): Promise<TransactionUnspentOutput[]>;
    // (undocumented)
    kupoUrl: string;
    // (undocumented)
    ogmios: Unwrapped.Ogmios;
    // (undocumented)
    static readonly plutusVersions: string[];
    postTransactionToChain(tx: Transaction): Promise<TransactionId>;
    resolveDatum(datumHash: DatumHash): Promise<PlutusData>;
    resolveUnspentOutputs(txIns: TransactionInput[]): Promise<TransactionUnspentOutput[]>;
    static serializeUtxos(unspentOutputs: TransactionUnspentOutput[]): Schema.Utxo;
}

// @public
export function makeValue(lovelace: bigint, ...assets: [string, bigint][]): Value_2;

// @public (undocumented)
const Metadata: typeof C.Serialization.GeneralTransactionMetadata;

// @public (undocumented)
type Metadata = C.Serialization.GeneralTransactionMetadata;

// @public (undocumented)
const Metadatum: typeof C.Serialization.TransactionMetadatum;

// @public (undocumented)
type Metadatum = C.Serialization.TransactionMetadatum;

// @public (undocumented)
const MetadatumList: typeof C.Serialization.MetadatumList;

// @public (undocumented)
type MetadatumList = C.Serialization.MetadatumList;

// @public (undocumented)
const MetadatumMap: typeof C.Serialization.MetadatumMap;

// @public (undocumented)
type MetadatumMap = C.Serialization.MetadatumMap;

// @public (undocumented)
interface MinFeeReferenceScripts {
    // (undocumented)
    base: number;
    // (undocumented)
    multiplier: number;
    // (undocumented)
    range: number;
}

// @public
const mnemonicToEntropy: typeof bip39.mnemonicToEntropy;

// @public
export type Namespace = "nami" | "eternl" | "flint" | "gerowallet" | "nufi" | "begin" | "lace" | "yoroi";

// @public (undocumented)
const NativeScript: typeof C.Serialization.NativeScript;

// @public (undocumented)
type NativeScript = C.Serialization.NativeScript;

// @public (undocumented)
namespace nativescript_d_exports {
        { address, after, allOf, anyOf, atLeastNOfK, before, justAddress };
}

// @public (undocumented)
const NetworkId: typeof C.Cardano.NetworkId;

// @public (undocumented)
type NetworkId = C.Cardano.ChainId["networkId"];

// @public (undocumented)
export type NetworkName = "cardano-mainnet" | "cardano-preprod" | "cardano-preview" | "cardano-sanchonet" | "unknown";

// @public (undocumented)
const PaymentAddress: (value: string) => C.Cardano.PaymentAddress;

// @public (undocumented)
type PaymentAddress = C.Cardano.PaymentAddress;

// @public (undocumented)
const PlutusData: typeof C.Serialization.PlutusData;

// @public (undocumented)
type PlutusData = C.Serialization.PlutusData;

// @public (undocumented)
const PlutusDataKind: typeof C.Serialization.PlutusDataKind;

// @public (undocumented)
type PlutusDataKind = C.Serialization.PlutusDataKind;

// @public (undocumented)
const PlutusLanguageVersion: typeof C.Cardano.PlutusLanguageVersion;

// @public (undocumented)
type PlutusLanguageVersion = C.Cardano.PlutusLanguageVersion;

// @public (undocumented)
const PlutusList: typeof C.Serialization.PlutusList;

// @public (undocumented)
type PlutusList = C.Serialization.PlutusList;

// @public (undocumented)
const PlutusMap: typeof C.Serialization.PlutusMap;

// @public (undocumented)
type PlutusMap = C.Serialization.PlutusMap;

// @public (undocumented)
const PlutusV1Script: typeof C.Serialization.PlutusV1Script;

// @public (undocumented)
type PlutusV1Script = C.Serialization.PlutusV1Script;

// @public (undocumented)
const PlutusV2Script: typeof C.Serialization.PlutusV2Script;

// @public (undocumented)
type PlutusV2Script = C.Serialization.PlutusV2Script;

// @public (undocumented)
const PlutusV3Script: typeof C.Serialization.PlutusV3Script;

// @public (undocumented)
type PlutusV3Script = C.Serialization.PlutusV3Script;

// @public (undocumented)
const PolicyId: (value: string) => C.Cardano.PolicyId;

// @public (undocumented)
type PolicyId = C.Cardano.PolicyId;

// @public
function PolicyIdToHash(policy: PolicyId): Hash28ByteBase16;

// @public (undocumented)
const PoolId: {
    (value: string): PoolId;
    fromKeyHash(value: Crypto.Ed25519KeyHashHex): PoolId;
    toKeyHash(poolId: PoolId): Crypto.Ed25519KeyHashHex;
};

// @public (undocumented)
type PoolId = OpaqueString<"PoolId">;

// @public (undocumented)
type Prettier = PlutusData | string | number | boolean | null;

// @public (undocumented)
function prettify(data: Prettier, indent?: string): string;

// @public
interface ProtocolParameters {
    coinsPerUtxoByte: number;
    collateralPercentage: number;
    costModels: Cardano.CostModels;
    desiredNumberOfPools: number;
    maxBlockBodySize: number;
    maxBlockHeaderSize: number;
    maxCollateralInputs: number;
    maxExecutionUnitsPerBlock: Cardano.ExUnits;
    maxExecutionUnitsPerTransaction: Cardano.ExUnits;
    maxTxSize: number;
    maxValueSize: number;
    minFeeCoefficient: number;
    minFeeConstant: number;
    minFeeReferenceScripts?: MinFeeReferenceScripts;
    minPoolCost: number;
    monetaryExpansion: string;
    poolDeposit: number | null;
    poolInfluence: string;
    poolRetirementEpochBound: number;
    prices: Cardano.Prices;
    protocolVersion: Cardano.ProtocolVersion;
    stakeKeyDeposit: number;
    treasuryExpansion: string;
}

// @public
export abstract class Provider {
    constructor(network: NetworkId, networkName: NetworkName);
    abstract awaitTransactionConfirmation(txId: TransactionId, timeout?: number): Promise<boolean>;
    abstract evaluateTransaction(tx: Transaction, additionalUtxos: TransactionUnspentOutput[]): Promise<Redeemers>;
    abstract getParameters(): Promise<ProtocolParameters>;
    getSlotConfig(): SlotConfig;
    abstract getUnspentOutputByNFT(unit: AssetId): Promise<TransactionUnspentOutput>;
    abstract getUnspentOutputs(address: Address): Promise<TransactionUnspentOutput[]>;
    abstract getUnspentOutputsWithAsset(address: Address, unit: AssetId): Promise<TransactionUnspentOutput[]>;
    // (undocumented)
    network: NetworkId;
    // (undocumented)
    networkName: NetworkName;
    abstract postTransactionToChain(tx: Transaction): Promise<TransactionId>;
    abstract resolveDatum(datumHash: DatumHash): Promise<PlutusData>;
    resolveScriptRef(script: Script | Hash28ByteBase16, address?: Address): Promise<TransactionUnspentOutput | undefined>;
    abstract resolveUnspentOutputs(txIns: TransactionInput[]): Promise<TransactionUnspentOutput[]>;
    slotToUnix(slot: Slot | number | bigint): number;
    unixToSlot(unix_millis: bigint | number): Slot;
}

// @public
export const purposeToTag: {
    [key: string]: number;
};

// @public (undocumented)
const Redeemer: typeof C.Serialization.Redeemer;

// @public (undocumented)
type Redeemer = C.Serialization.Redeemer;

// @public (undocumented)
const RedeemerPurpose: typeof C.Cardano.RedeemerPurpose;

// @public (undocumented)
type RedeemerPurpose = C.Cardano.RedeemerPurpose;

// @public (undocumented)
const Redeemers: typeof C.Serialization.Redeemers;

// @public (undocumented)
type Redeemers = C.Serialization.Redeemers;

// @public (undocumented)
const RedeemerTag: typeof C.Serialization.RedeemerTag;

// @public (undocumented)
type RedeemerTag = C.Serialization.RedeemerTag;

// @public (undocumented)
const RewardAccount: {
    (value: string): C.Cardano.RewardAccount;
    toHash(rewardAccount: C.Cardano.RewardAccount): Hash28ByteBase16;
    fromCredential(credential: C.Cardano.Credential, networkId: C.Cardano.NetworkId): C.Cardano.RewardAccount;
    toNetworkId(rewardAccount: C.Cardano.RewardAccount): C.Cardano.NetworkId;
};

// @public (undocumented)
type RewardAccount = OpaqueString<"RewardAccount">;

// @public (undocumented)
const RewardAddress: typeof C.Cardano.RewardAddress;

// @public (undocumented)
type RewardAddress = C.Cardano.RewardAddress;

// @public (undocumented)
const Script: typeof C.Serialization.Script;

// @public (undocumented)
type Script = C.Serialization.Script;

// @public (undocumented)
const ScriptAll: typeof C.Serialization.ScriptAll;

// @public (undocumented)
type ScriptAll = C.Serialization.ScriptAll;

// @public (undocumented)
const ScriptAny: typeof C.Serialization.ScriptAny;

// @public (undocumented)
type ScriptAny = C.Serialization.ScriptAny;

// @public (undocumented)
type ScriptHash = Crypto.Hash28ByteBase16;

// @public (undocumented)
const ScriptNOfK: typeof C.Serialization.ScriptNOfK;

// @public (undocumented)
type ScriptNOfK = C.Serialization.ScriptNOfK;

// @public (undocumented)
const ScriptPubkey: typeof C.Serialization.ScriptPubkey;

// @public (undocumented)
type ScriptPubkey = C.Serialization.ScriptPubkey;

// @public (undocumented)
export type ScriptType = "Native" | "PlutusV1" | "PlutusV2" | "PlutusV3";

// @public (undocumented)
type SelectionPhase = "wide" | "deep" | "final";

// @public
const setInConwayEra: (value: boolean) => false;

// @public
function sha2_256(data: HexBlob): Hash32ByteBase16;

// @public
function sha3_256(data: HexBlob): Hash32ByteBase16;

// @public
function signMessage(message: HexBlob, privateKey: Ed25519PrivateNormalKeyHex | Ed25519PrivateExtendedKeyHex): Ed25519SignatureHex;

// @public (undocumented)
const Slot: (value: number) => C.Cardano.Slot;

// @public (undocumented)
type Slot = C.Cardano.Slot;

// @public (undocumented)
const SLOT_CONFIG_NETWORK: {
    Mainnet: {
        zeroTime: number;
        zeroSlot: number;
        slotLength: number;
    };
    Preview: {
        zeroTime: number;
        zeroSlot: number;
        slotLength: number;
    };
    Preprod: {
        zeroTime: number;
        zeroSlot: number;
        slotLength: number;
    };
};

// @public
interface SlotConfig {
    // (undocumented)
    slotLength: number;
    // (undocumented)
    zeroSlot: number;
    // (undocumented)
    zeroTime: number;
}

// @public
export function sortLargestFirst(inputs: TransactionUnspentOutput[]): TransactionUnspentOutput[];

// @public (undocumented)
const StakeDelegation: typeof C.Serialization.StakeDelegation;

// @public (undocumented)
type StakeDelegation = C.Serialization.StakeDelegation;

// @public (undocumented)
type StakeDelegationCertificate = C.Cardano.StakeDelegationCertificate;

// @public (undocumented)
const StakeDeregistration: typeof C.Serialization.StakeDeregistration;

// @public (undocumented)
type StakeDeregistration = C.Serialization.StakeDeregistration;

// @public (undocumented)
const StakeRegistration: typeof C.Serialization.StakeRegistration;

// @public (undocumented)
type StakeRegistration = C.Serialization.StakeRegistration;

// @public
export const stringifyBigint: typeof JSON.stringify;

// @public (undocumented)
const TimelockExpiry: typeof C.Serialization.TimelockExpiry;

// @public (undocumented)
type TimelockExpiry = C.Serialization.TimelockExpiry;

// @public (undocumented)
const TimelockStart: typeof C.Serialization.TimelockStart;

// @public (undocumented)
type TimelockStart = C.Serialization.TimelockStart;

// @public
function toHex(byteArray: Uint8Array): string;

// @public (undocumented)
type TokenMap = C.Cardano.TokenMap;

// @public (undocumented)
const Transaction: typeof C.Serialization.Transaction;

// @public (undocumented)
type Transaction = C.Serialization.Transaction;

// @public (undocumented)
const TransactionBody: typeof C.Serialization.TransactionBody;

// @public (undocumented)
type TransactionBody = C.Serialization.TransactionBody;

// @public (undocumented)
const TransactionId: {
    (value: string): C.Cardano.TransactionId;
    fromHexBlob(value: _cardano_sdk_util0.HexBlob): C.Cardano.TransactionId;
};

// @public (undocumented)
type TransactionId = C.Cardano.TransactionId;

// @public (undocumented)
const TransactionInput: typeof C.Serialization.TransactionInput;

// @public (undocumented)
type TransactionInput = C.Serialization.TransactionInput;

// @public (undocumented)
type TransactionInputSet = C.Serialization.CborSet<ReturnType<TransactionInput["toCore"]>, TransactionInput>;

// @public (undocumented)
const TransactionMetadatumKind: typeof C.Serialization.TransactionMetadatumKind;

// @public (undocumented)
type TransactionMetadatumKind = C.Serialization.TransactionMetadatumKind;

// @public (undocumented)
const TransactionOutput: typeof C.Serialization.TransactionOutput;

// @public (undocumented)
type TransactionOutput = C.Serialization.TransactionOutput;

// @public (undocumented)
const TransactionUnspentOutput: typeof C.Serialization.TransactionUnspentOutput;

// @public (undocumented)
type TransactionUnspentOutput = C.Serialization.TransactionUnspentOutput;

// @public (undocumented)
type TransactionWitnessPlutusData = Set<PlutusData>;

// @public (undocumented)
const TransactionWitnessSet: typeof C.Serialization.TransactionWitnessSet;

// @public (undocumented)
type TransactionWitnessSet = C.Serialization.TransactionWitnessSet;

// @public
export class TxBuilder {
    constructor(params: ProtocolParameters, tracing?: boolean);
    addAdditionalSigners(amount: number): TxBuilder;
    addDelegation(delegator: Credential, poolId: PoolId, redeemer?: PlutusData): TxBuilder;
    addDeregisterStake(credential: Credential, redeemer?: PlutusData): TxBuilder;
    addInput(utxo: TransactionUnspentOutput, redeemer?: PlutusData, unhashDatum?: PlutusData): TxBuilder;
    addMint(policy: PolicyId, assets: Map<AssetName, bigint>, redeemer?: PlutusData): this;
    addOutput(output: TransactionOutput): TxBuilder;
    addPreCompleteHook(hook: (tx: TxBuilder) => Promise<void>): TxBuilder;
    addReferenceInput(utxo: TransactionUnspentOutput): TxBuilder;
    addRegisterPool(): void;
    addRegisterStake(credential: Credential): this;
    addRequiredSigner(signer: Ed25519KeyHashHex): TxBuilder;
    addRetirePool(): void;
    addUnspentOutputs(utxos: TransactionUnspentOutput[]): TxBuilder;
    addWithdrawal(address: RewardAccount, amount: bigint, redeemer?: PlutusData): TxBuilder;
    protected buildFinalWitnessSet(signatures: [Ed25519PublicKeyHex, Ed25519SignatureHex][]): TransactionWitnessSet;
    protected buildPlaceholderWitnessSet(): TransactionWitnessSet;
    get burnAddress(): Address;
    protected calculateFees(): void;
    complete(params?: UseCoinSelectionArgs): Promise<Transaction>;
    delegate(poolId: PoolId, redeemer?: PlutusData): this;
    deployScript(script: Script, address?: Address): TxBuilder;
    enableTracing(enabled: boolean): TxBuilder;
    protected getScriptData(tw: TransactionWitnessSet): IScriptData | undefined;
    lockAssets(address: Address, value: Value_2, datum: Datum, scriptReference?: Script): TxBuilder;
    lockLovelace(address: Address, lovelace: bigint, datum: Datum, scriptReference?: Script): TxBuilder;
    get outputsCount(): number;
    // (undocumented)
    readonly params: ProtocolParameters;
    payAssets(address: Address, value: Value_2, datum?: Datum): TxBuilder;
    payLovelace(address: Address, lovelace: bigint, datum?: Datum): TxBuilder;
    // Warning: (ae-forgotten-export) The symbol "UseCoinSelectionArgs" needs to be exported by the entry point index.d.ts
    protected prepareCollateral(params?: UseCoinSelectionArgs): void;
    provideCollateral(utxos: TransactionUnspentOutput[]): TxBuilder;
    provideDatum(datum: PlutusData): TxBuilder;
    provideScript(script: Script): TxBuilder;
    setAuxiliaryData(auxiliaryData: AuxiliaryData): TxBuilder;
    setChangeAddress(address: Address, override?: boolean): TxBuilder;
    setCollateralChangeAddress(address: Address): TxBuilder;
    setDonation(donation: bigint): TxBuilder;
    setFeePadding(pad: bigint): TxBuilder;
    setMetadata(metadata: Metadata): TxBuilder;
    setMinimumFee(fee: bigint): TxBuilder;
    setNetworkId(networkId: NetworkId): TxBuilder;
    setRewardAddress(address: Address): TxBuilder;
    setValidFrom(validFrom: Slot): TxBuilder;
    setValidUntil(validUntil: Slot): TxBuilder;
    toCbor(): string;
    // Warning: (ae-forgotten-export) The symbol "SelectionResult" needs to be exported by the entry point index.d.ts
    useCoinSelector(selector: (inputs: TransactionUnspentOutput[], dearth: Value_2) => SelectionResult): TxBuilder;
    useEvaluator(evaluator: Evaluator, override?: boolean): TxBuilder;
}

// @public (undocumented)
const TxCBOR: {
    (tx: string): C.Serialization.TxCBOR;
    serialize(tx: C.Cardano.Tx): C.Serialization.TxCBOR;
    deserialize(tx: C.Serialization.TxCBOR): C.Cardano.Tx;
};

// @public (undocumented)
type TxCBOR = C.Serialization.TxCBOR;

// Warning: (ae-forgotten-export) The symbol "Parser" needs to be exported by the entry point index.d.ts
//
// @public
export class UPLCDecoder extends Parser {
    // Warning: (ae-forgotten-export) The symbol "ParsedProgram" needs to be exported by the entry point index.d.ts
    decode(): ParsedProgram;
    static decodeFromHex(hex: string): ParsedProgram;
    static fromHex(hex: string): UPLCDecoder;
}

// Warning: (ae-forgotten-export) The symbol "Encoder" needs to be exported by the entry point index.d.ts
//
// @public
export class UPLCEncoder extends Encoder {
    encodeBool(value: boolean): void;
    encodeByteString(bytes: Uint8Array): void;
    encodeConst(type: DataType, value: Data): void;
    // Warning: (ae-forgotten-export) The symbol "DataType" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "Data" needs to be exported by the entry point index.d.ts
    encodeData(type: DataType, data: Data): void;
    encodeInteger(i: bigint): void;
    // (undocumented)
    encodeList<T>(items: T[], encode: (t: T) => void): void;
    encodeNatural(n: bigint): void;
    encodeProgram(program: ParsedProgram): Uint8Array;
    // Warning: (ae-forgotten-export) The symbol "ParsedTerm" needs to be exported by the entry point index.d.ts
    encodeTerm(term: ParsedTerm): void;
    encodeType(type: DataType): number[];
    // Warning: (ae-forgotten-export) The symbol "SemVer" needs to be exported by the entry point index.d.ts
    encodeVersion(version: SemVer): void;
}

// @public (undocumented)
class UTxOSelectionError extends Error {
    constructor(phase: SelectionPhase, dearth: Value_2, availableInputs?: TransactionUnspentOutput[] | undefined, selectedInputs?: TransactionUnspentOutput[] | undefined, bestStep?: [bigint | number, Value_2, number] | undefined);
    // (undocumented)
    availableInputs?: TransactionUnspentOutput[] | undefined;
    // (undocumented)
    bestStep?: [bigint | number, Value_2, number] | undefined;
    // (undocumented)
    dearth: Value_2;
    // (undocumented)
    phase: SelectionPhase;
    // (undocumented)
    selectedInputs?: TransactionUnspentOutput[] | undefined;
}

// @public (undocumented)
export namespace Value {
        { assetTypes, assets, empty, intersect, makeValue, merge, negate, negatives, positives, sub, sum, zero };
}

// @public (undocumented)
const Value_2: typeof C.Serialization.Value;

// @public (undocumented)
type Value_2 = C.Serialization.Value;

// @public (undocumented)
const VkeyWitness: typeof C.Serialization.VkeyWitness;

// @public (undocumented)
type VkeyWitness = C.Serialization.VkeyWitness;

// @public
export abstract class Wallet {
    abstract getBalance(): Promise<Value_2>;
    abstract getChangeAddress(): Promise<Address>;
    abstract getCollateral(): Promise<TransactionUnspentOutput[]>;
    abstract getNetworkId(): Promise<NetworkId>;
    abstract getRewardAddresses(): Promise<RewardAddress[]>;
    abstract getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    abstract getUnusedAddresses(): Promise<Address[]>;
    abstract getUsedAddresses(): Promise<Address[]>;
    abstract postTransaction(tx: Transaction): Promise<TransactionId>;
    abstract signData(address: Address, payload: string): Promise<CIP30DataSignature>;
    abstract signTransaction(tx: Transaction, partialSign: boolean): Promise<TransactionWitnessSet>;
}

// Warning: (ae-forgotten-export) The symbol "Wallet$1" needs to be exported by the entry point index.d.ts
//
// @public
export const WalletDetails: Wallet$1[];

// @public
export class WebWallet implements Wallet {
    constructor(webWallet: CIP30Interface);
    getBalance(): Promise<Value_2>;
    getChangeAddress(): Promise<Address>;
    getCollateral(): Promise<TransactionUnspentOutput[]>;
    getNetworkId(): Promise<NetworkId>;
    getRewardAddresses(): Promise<RewardAddress[]>;
    getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    getUnusedAddresses(): Promise<Address[]>;
    getUsedAddresses(): Promise<Address[]>;
    postTransaction(tx: Transaction): Promise<TransactionId>;
    signData(address: Address, payload: string): Promise<CIP30DataSignature>;
    signTransaction(tx: Transaction, partialSign: boolean): Promise<TransactionWitnessSet>;
}

// (No @packageDocumentation comment for this package)

```
