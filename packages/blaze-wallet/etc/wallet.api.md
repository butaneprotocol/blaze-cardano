## API Report File for "@blaze-cardano/wallet"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Address } from '@blaze-cardano/core';
import { AddressType } from '@blaze-cardano/core';
import { Bip32PrivateKey } from '@blaze-cardano/core';
import type { Bip32PrivateKeyHex } from '@blaze-cardano/core';
import type { Bip32PublicKey } from '@blaze-cardano/core';
import type { Ed25519PrivateNormalKeyHex } from '@blaze-cardano/core';
import type { HexBlob } from '@blaze-cardano/core';
import { NetworkId } from '@blaze-cardano/core';
import type { Provider } from '@blaze-cardano/query';
import { RewardAddress } from '@blaze-cardano/core';
import type { Transaction } from '@blaze-cardano/core';
import { TransactionId } from '@blaze-cardano/core';
import { TransactionUnspentOutput } from '@blaze-cardano/core';
import { TransactionWitnessSet } from '@blaze-cardano/core';
import { Value } from '@blaze-cardano/core';

// @public (undocumented)
export interface CIP30DataSignature {
    // Warning: (ae-forgotten-export) The symbol "CoseKeyCborHex" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    key: CoseKeyCborHex;
    // Warning: (ae-forgotten-export) The symbol "CoseSign1CborHex" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    signature: CoseSign1CborHex;
}

// @public
export interface CIP30Interface {
    getBalance(): Promise<string>;
    getChangeAddress(): Promise<string>;
    getCollateral(): Promise<string[]>;
    getNetworkId(): Promise<number>;
    getRewardAddresses(): Promise<string[]>;
    getUnusedAddresses(): Promise<string[]>;
    getUsedAddresses(): Promise<string[]>;
    getUtxos(): Promise<string[] | undefined>;
    signData(address: string, payload: string): Promise<{
        signature: string;
        key: string;
    }>;
    signTx(tx: string, partialSign: boolean): Promise<string>;
    submitTx(tx: string): Promise<string>;
}

// @public
export class ColdWallet implements Wallet {
    constructor(address: Address, networkId: NetworkId, provider: Provider);
    // (undocumented)
    readonly address: Address;
    getBalance(): Promise<Value>;
    getChangeAddress(): Promise<Address>;
    getCollateral(): Promise<TransactionUnspentOutput[]>;
    getNetworkId(): Promise<NetworkId>;
    getRewardAddresses(): Promise<RewardAddress[]>;
    getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    getUnusedAddresses(): Promise<Address[]>;
    getUsedAddresses(): Promise<Address[]>;
    // (undocumented)
    readonly networkId: NetworkId;
    postTransaction(tx: Transaction): Promise<TransactionId>;
    signData(_address: Address, _payload: string): Promise<CIP30DataSignature>;
    signTransaction(_tx: Transaction, _partialSign?: boolean): Promise<TransactionWitnessSet>;
}

// @public
export class HotSingleWallet implements Wallet {
    constructor(paymentSigningKey: Ed25519PrivateNormalKeyHex, networkId: NetworkId, provider: Provider, stakeSigningKey?: Ed25519PrivateNormalKeyHex);
    // (undocumented)
    readonly address: Address;
    getBalance(): Promise<Value>;
    getChangeAddress(): Promise<Address>;
    getCollateral(): Promise<TransactionUnspentOutput[]>;
    getNetworkId(): Promise<NetworkId>;
    getRewardAddresses(): Promise<RewardAddress[]>;
    getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    getUnusedAddresses(): Promise<Address[]>;
    getUsedAddresses(): Promise<Address[]>;
    // (undocumented)
    readonly networkId: NetworkId;
    postTransaction(tx: Transaction): Promise<TransactionId>;
    signData(address: Address, payload: string): Promise<CIP30DataSignature>;
    signTransaction(tx: Transaction, partialSign?: boolean): Promise<TransactionWitnessSet>;
}

// @public
export class HotWallet implements Wallet {
    // (undocumented)
    readonly address: Address;
    // (undocumented)
    static fromMasterkey(masterkey: Bip32PrivateKeyHex, provider: Provider, networkId?: NetworkId, addressType?: AddressType): Promise<HotWallet>;
    // (undocumented)
    static generateAccountAddressFromMasterkey(masterkey: Bip32PrivateKey, networkId?: NetworkId, addressType?: AddressType): Promise<{
        address: Address;
        paymentKey: Bip32PrivateKey;
        stakePaymentKey: Bip32PrivateKey;
        publicKey: Bip32PublicKey;
    }>;
    getBalance(): Promise<Value>;
    getChangeAddress(): Promise<Address>;
    getCollateral(): Promise<TransactionUnspentOutput[]>;
    getNetworkId(): Promise<NetworkId>;
    getRewardAddresses(): Promise<RewardAddress[]>;
    getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    getUnusedAddresses(): Promise<Address[]>;
    getUsedAddresses(): Promise<Address[]>;
    // (undocumented)
    readonly networkId: NetworkId;
    postTransaction(tx: Transaction): Promise<TransactionId>;
    // (undocumented)
    readonly rewardAddress: RewardAddress | undefined;
    signData(address: Address, payload: string): Promise<CIP30DataSignature>;
    signTransaction(tx: Transaction, partialSign?: boolean, signWithStakeKey?: boolean): Promise<TransactionWitnessSet>;
}

// @public
export type Namespace = "nami" | "eternl" | "flint" | "gerowallet" | "nufi" | "begin" | "lace" | "yoroi";

// @public
export abstract class Wallet {
    abstract getBalance(): Promise<Value>;
    abstract getChangeAddress(): Promise<Address>;
    abstract getCollateral(): Promise<TransactionUnspentOutput[]>;
    abstract getNetworkId(): Promise<NetworkId>;
    abstract getRewardAddresses(): Promise<RewardAddress[]>;
    abstract getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    abstract getUnusedAddresses(): Promise<Address[]>;
    abstract getUsedAddresses(): Promise<Address[]>;
    abstract postTransaction(tx: Transaction): Promise<TransactionId>;
    abstract signData(address: Address, payload: string): Promise<CIP30DataSignature>;
    abstract signTransaction(tx: Transaction, partialSign: boolean): Promise<TransactionWitnessSet>;
}

// Warning: (ae-forgotten-export) The symbol "Wallet_2" needs to be exported by the entry point index.d.ts
//
// @public
export const WalletDetails: Wallet_2[];

// @public
export class WebWallet implements Wallet {
    constructor(webWallet: CIP30Interface);
    getBalance(): Promise<Value>;
    getChangeAddress(): Promise<Address>;
    getCollateral(): Promise<TransactionUnspentOutput[]>;
    getNetworkId(): Promise<NetworkId>;
    getRewardAddresses(): Promise<RewardAddress[]>;
    getUnspentOutputs(): Promise<TransactionUnspentOutput[]>;
    getUnusedAddresses(): Promise<Address[]>;
    getUsedAddresses(): Promise<Address[]>;
    postTransaction(tx: Transaction): Promise<TransactionId>;
    signData(address: Address, payload: string): Promise<CIP30DataSignature>;
    signTransaction(tx: Transaction, partialSign: boolean): Promise<TransactionWitnessSet>;
}

// (No @packageDocumentation comment for this package)

```
